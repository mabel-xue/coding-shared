# What's Solution

## âœ˜ ç”¨å¼‚æ­¥å®ç°å­—å…¸ç®¡é“ | Angular

æœªèƒ½å®ç°ï¼ŒåŸå› ï¼š

async-pipeæ ¹æ®å…¥å‚obj(Observable)éšæ—¶å˜åŠ¨ä¸åœçš„è§¦å‘ï¼Œå¦‚æœåœ¨pipeå†…éƒ¨è®¢é˜…åˆ™æ— æ³•è¿”å›è®¢é˜…æ•°æ®

ğŸ’¬[async-pipeæºç ](https://github.com/angular/angular/blob/master/packages/common/src/pipes/async_pipe.ts)

è§£å†³ï¼š

ä¸ç”¨å°†å¼‚æ­¥å†™æ—©ç®¡é“ä¸­ï¼Œå› åˆ©ç”¨async-pipeè¿”å›çš„å€¼ç›´æ¥å¤„ç†å­—å…¸å–å€¼æ“ä½œï¼Œè¯¦è§å¦‚ä¸‹ï¼š

## å·²çŸ¥å­—å…¸è¡¨valueå€¼ï¼Œåæ˜¾å¯¹åº”label | Angular/æœ€ä½³å®è·µ

> åœºæ™¯ç¤ºä¾‹:scfp

```html
<sv label="åŸæ“ä½œäººè¯ä»¶ç±»å‹">{{ dictSrv.CrdtTp$ | async | arrFind: info?.oldHandleSnType:'value':'label' }}</sv>
```

```js
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'arrFind',
})
export class ArrFindPipe implements PipeTransform {
  transform(arr: any[], value, findKey, showKey?, equal: boolean = true): any {
    if (Array.isArray(arr) && value) {
      const data = arr.find(item => {
        if (equal) {
          return item[findKey] === value;
        } else {
          return value.includes(item[findKey]);
        }
      });
      return showKey ? (data ? data[showKey] : data) : data;
    }
    return value;
  }
}
```

## Rxjsä¸­å°†æµè½¬ä¸ºæ•°ç»„æµ | Angular/Rxjs

### èƒŒæ™¯

åœ¨ä¸­å°é¡¹ç›®ä¸­ï¼Œæƒ³è¦å°†å­—å…¸è¡¨æ•°æ®åœ¨è®¢é˜…å‰è¿›è¡Œ é€šè¿‡valueè·å–label çš„æ“ä½œï¼Œ

é”™è¯¯ç¤ºä¾‹ï¼š

```js
valueTrans(dictType: string, value: string | number): Observable<string> {
  return this.getDictCache(dictType).pipe(
    filter((item: any) => value === item.value),
    map(item => item.label),
    catchError(error => of(value))
  );
}
```

åŸå› ï¼šå°†å­—å…¸è¡¨è¿”å›çš„æ•°æ®å½“æˆæ•°ç»„æµå¤„ç†ï¼Œåº”è¯¥å…ˆå°†æ™®é€šæµè½¬ä¸ºæ•°ç»„æµå†è¿›è¡Œæ“ä½œã€‚

### è§£å†³

```js
items$.pipe(mergeMap((items: any[]) => {
  return items.map((item: any) => item);
}));
```

### é¡¹ç›®ä»£ç 

```js
valueTrans(dictType: string, value: string | number): Observable<string> {
  return this.getDictCache(dictType).pipe(
    mergeMap(items => items.map(item => item)),
    filter((item: any) => value === item.value),
    map(item => item.label),
    catchError(error => of(value))
  );
}
```

### è¡¥å……: ç”¨fromç›´æ¥è½¬ä¸ºæ•°ç»„æµ

```js
valueTrans(dictType: string, value: string | number): Observable<string> {
  return from(this.getDictCache(dictType)).pipe(
    filter((item: any) => value === item.value),
    map(item => item.label),
    catchError(error => of(value))
  );
}
```
