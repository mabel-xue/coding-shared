代码书写优化&重构方案

命名

坚持遵循同一个模式来描述符号的特性和类型。推荐的模式为 feature.type.ts
class
type
modal
api
文件名
使用点和横杠来分隔
符号名与文件名
坚持 在描述性名字中，用横杠来分隔单词。
坚持使用点来分隔描述性名字和类型。
坚持使用大写驼峰命名法来命名类。符号名匹配它所在的文件名。
服务名
风格 02-04
为服务的类名加上 Service 后缀。 例如，DataService 或 HeroService。

组件选择器
风格 05-02
坚持使用中线命名法（dashed-case）或叫烤串命名法（kebab-case）来命名组件的元素选择器。

为组件添加自定义前缀
"app",
        "passport",
        "exception",
        "layout",
        "header",
        "btx",
        "page",
        "nz",
        "bi",
        "pm"

成员顺序
风格 05-14
坚持把属性成员放在前面，方法成员放在后面。
坚持先放公共成员，再放私有成员，并按照字母顺序排列。

不要给输出属性加前缀
风格 05-16
坚持命名事件时，不要带前缀 on。
坚持把事件处理器方法命名为 on 前缀之后紧跟着事件名。
为何？与内置事件命名一致，例如按钮点击。
为何？Angular 允许另一种备选语法 on-*。如果事件的名字本身带有前缀 on，那么绑定的表达式可能是 on-onEvent。


@Component({
  selector: 'toh-hero',
  template: `...`
})
export class HeroComponent {
	/* avoid */
  @Output() onSavedTheDay = new EventEmitter<boolean>();
@Output() savedTheDay = new EventEmitter<boolean>();
}

把表现层逻辑放到组件类里
风格 05-17
坚持把表现层逻辑放进组件类中，而不要放在模板里。
为何？逻辑应该只出现在一个地方（组件类里）而不应分散在两个地方。
为何？将组件的表现层逻辑放到组件类而非模板里，可以增强测试性、维护性和重复使用性。
```js
/* avoid */

@Component({
  selector: 'toh-hero-list',
  template: `
    <section>
      Our list of heroes:
      <hero-profile *ngFor="let hero of heroes" [hero]="hero">
      </hero-profile>
      Total powers: {{totalPowers}}<br>
      Average power: {{totalPowers / heroes.length}}
    </section>
  `
})
export class HeroListComponent {
  heroes: Hero[];
  totalPowers: number;
}

@Component({
  selector: 'toh-hero-list',
  template: `
    <section>
      Our list of heroes:
      <toh-hero *ngFor="let hero of heroes" [hero]="hero">
      </toh-hero>
      Total powers: {{totalPowers}}<br>
      Average power: {{avgPower}}
    </section>
  `
})
export class HeroListComponent {
  heroes: Hero[];
  totalPowers: number;

  get avgPower() {
    return this.totalPowers / this.heroes.length;
  }
}
```

HostListener 和 HostBinding 装饰器 vs. 组件元数据 host
风格 06-03
考虑优先使用 @HostListener 和 @HostBinding，而不是 @Directive 和 @Component 装饰器的 host 属性。

坚持让你的选择保持一致。

为何？对于关联到 @HostBinding 的属性或关联到 @HostListener 的方法，要修改时，只需在指令类中的一个地方修改。 如果使用元数据属性 host，你就得在组件类中修改属性声明的同时修改相关的元数据。

使用 @Injectable() 类装饰器
风格 07-04
坚持当使用类型作为令牌来注入服务的依赖时，使用 @Injectable() 类装饰器，而非 @Inject() 参数装饰器。

为何？ Angular 的 DI 机制会根据服务的构造函数参数的声明类型来解析服务的所有依赖。

为何？当服务只接受类型令牌相关的依赖时，比起在每个构造函数参数上使用 @Inject()，@Injectable() 的语法简洁多了。


把逻辑放到服务里
风格 05-15
坚持在组件中只包含与视图相关的逻辑。所有其它逻辑都应该放到服务中。
坚持把可重用的逻辑放到服务中，保持组件简单，聚焦于它们预期目的。
为何？当逻辑被放置到服务里，并以函数的形式暴露时，可以被多个组件重复使用。
为何？在单元测试时，服务里的逻辑更容易被隔离。当组件中调用逻辑时，也很容易被模拟。
为何？从组件移除依赖并隐藏实现细节。
为何？保持组件苗条、精简和聚焦。

指令
使用指令来增强已有元素
风格 06-01
坚持当你需要有表现层逻辑，但没有模板时，使用属性型指令。
为何？属性型指令没有模板。
为何？一个元素可以使用多个属性型指令。

数据服务
通过服务与 Web 服务器通讯
风格 08-01
坚持把数据操作和与数据交互的逻辑重构到服务里。

坚持让数据服务来负责 XHR 调用、本地储存、内存储存或者其它数据操作。

为何？组件的职责是为视图展示或收集信息。它不应该关心如何获取数据，它只需要知道向谁请求数据。把如何获取数据的逻辑移动到数据服务里，简化了组件，让其聚焦于视图。

为何？在测试使用数据服务的组件时，可以让数据调用更容易被测试（模拟或者真实）。

为何？数据管理的详情，比如头信息、方法、缓存、错误处理和重试逻辑，不是组件和其它的数据消费者应该关心的事情。

数据服务应该封装这些细节。这样，在服务内部修改细节，就不会影响到它的消费者。并且更容易通过实现一个模拟服务来对消费者进行测试。



```js
pokemon$.subscribe((pokemon: Pokemon) => {
  if (pokemon.type !== "Water") {
    return;
  }
  const pokemonStats = getStats(pokemon);
  logStats(pokemonStats);
  saveToPokedex(pokemonStats);
});
```


```js
pokemon$
  .pipe(
    filter(({ type }) => type === "Water"),
    map(pokemon => getStats(pokemon)),
    tap(stats => logStats(stats))
  )
  .subscribe(stats => saveToPokedex(stats));
```


Using Subjects to Force Completion
```js
const stop$ = new Subject<void>();

trainer$
  .pipe(takeUntil(stop$)).subscribe(trainer => {
    // Do something with trainer
  });

pokemon$
  .pipe(takeUntil(stop$)).subscribe(pokemon => {
    // Do something with pokemon
  });

number$
  .pipe(takeUntil(stop$)).subscribe(number => {
    // Do something with number
  });

function stop() {
  stop$.next();
  stop$.complete();
}
```